### 1. 关键字：static[#](https://www.cnblogs.com/deyo/p/17496096.html#1-%E5%85%B3%E9%94%AE%E5%AD%97static)

```markdown
2. static 用来修饰的结构：属性、方法;代码块、内部类

3. static修饰属性
   3.1 复习：变量的分类
   方式1：按照数据类型： 基本数据类型、引用数据类型

   方式2：按照类中声明的位置：
    成员变量（或属性）：以是否使用static修饰
        > 使用static修饰 ：  类变量（或静态变量）
        > 不使用static修饰 ： 实例变量（或非静态变量）

    局部变量：方法内声明的变量、方法形参、构造器内声明的变量、构造器形参、代码块内声明的变量等。


   3.2 静态变量：类中的属性使用static进行修饰。
       对比静态变量与实例变量：
       ① 个数
        >静态变量：内存中只存在一份。与具体对象的个数，以及是否存在对象都无关。
        >实例变量：归属于具体的对象所有。进而创建过几个对象，就存在一个实例变量。

       ② 内存位置
        >静态变量：jdk6:存放在方法区。 从jdk7开始，存放在堆空间中。（注意：不在具体的对象内部）
        >实例变量：堆空间存储了对象实体。在具体的对象实体中，保存着实例变量。

       ③ 加载时机
        >静态变量：随着类的加载而加载。（即类加载完成时，此静态变量就分配好了内存空间）
        >实例变量：随着对象的创建，在堆空间此对象内部，分配内存存储具体的实例变量。

       ④ 调用者
        >静态变量：可以被类调用，也可以被类的对象调用。
        >实例变量：只能被类的对象调用

       ⑤ 判断是否可以调用 ---> 从生命周期的角度解释
                    类变量         实例变量
         类          yes             no
         对象        yes             yes
       ⑥ 消亡时机
        >静态变量：随着类的卸载而消亡。
        >实例变量：随着对象的消亡而消亡。



4. static修饰方法：（类方法、静态方法）
    > 随着类的加载而加载
    > 静态方法，可以使用"类.静态方法"的方式进行调用
      同时，还可以使用"对象.静态方法"的方式进行调用。--->从生命周期的角度解释
    > 判断是否可以调用
                          类方法         实例方法
               类          yes             no
               对象        yes             yes
    > 静态方法中只能调用当前类中的静态的变量、静态的方法。（即不能调用非静态的变量、非静态的方法）
      非静态的方法中既可以调用当前类中非静态的变量、非静态的方法，也可以调用静态的变量、静态的方法。

    > 静态方法中不能使用this、super关键字。

5. 开发中，什么时候需要将属性声明为静态的？

    > 是否适合被类的多个对象所共享，同时多个对象对应的此变量值是相同的。
    > 开发中，常常将一些常量声明为静态的。比如：Math的PI。


   什么时候需要将方法声明为静态的？

    > 操作静态变量的方法，通常设置为静态方法
    > 开发中，工具类中的方法常常设置为static的。
```

### 2. 单例模式[#](https://www.cnblogs.com/deyo/p/17496096.html#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F)

```markdown
1. 设计模式概述：
设计模式是在大量的`实践中总结`和`理论化`之后优选的代码结构、编程风格、以及解决问题的思考方式。
设计模式免去我们自己再思考和摸索。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。


2. 何为单例模式(Singleton)：在整个软件系统中，针对于某个类来讲，只存在该类的唯一的一个实例。则此类的设计
即为单例模式。

3. 如何实现单例模式（掌握）:

饿汉式、懒汉式


4. 对比两种模式（特点、优缺点）
特点：
    饿汉式：随着类的加载，当前类的实例就创建成功。
    懒汉式：只有在首次调用get()方法时，才会创建单例对应类的实例。

饿汉式：（缺点）类一加载对象就创建成功，占用内存时间较长。（优点）线程安全的。
懒汉式：（优点）延迟了对象的创建，节省内存空间。（缺点）线程不安全的。 --->后续多线程章节中，将此方式改为线程安全的。

【面试题】 写一个（线程安全的）单例模式。
```

### 3. main()的理解（了解）[#](https://www.cnblogs.com/deyo/p/17496096.html#3-main%E7%9A%84%E7%90%86%E8%A7%A3%E4%BA%86%E8%A7%A3)

```scss
1. 理解1：程序的入口。
   理解2：看做是一个普通的有形参的静态方法。

2. 与控制台交互(了解即可)

方式1：使用Scanner类及其内部的nextXxx()
方式2：使用main()，将从控制台获取的数据存储在其形参String[] args中。
```

### 4. 类的内部成员之四：代码块[#](https://www.cnblogs.com/deyo/p/17496096.html#4-%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%E4%BB%A3%E7%A0%81%E5%9D%97)

### 4.1 代码块的基本使用[#](https://www.cnblogs.com/deyo/p/17496096.html#41-%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8)

```markdown
1. 代码块（或初始化块）的作用：用来对类或对象进行初始化操作的。

2. 代码块的修饰：只能使用static修饰。


3. 代码块的分类：静态代码块、非静态代码块


4. 具体使用：
4.1 静态代码块：
    > 随着类的加载而执行。主要用来初始化类。
    > 因为类只加载一次，进而静态代码块也只会执行一次
    > 内部可以有输出语句、声明变量等操作
    > 内部可以调用当前类中静态的结构（属性、方法），不能调用非静态的结构
    > 如果一个类中声明了多个静态代码块，按照声明的顺序先后执行
    > 静态代码块的执行要先于非静态代码块的执行

4.2 非静态代码块：
    > 随着对象的创建而执行。主要用来初始化对象。
    > 每创建一个对象，非静态代码块就执行一次。
    > 内部可以有输出语句、声明变量等操作
    > 内部可以调用当前类中静态的结构（属性、方法），能调用非静态的结构
    > 如果一个类中声明了多个非静态代码块，按照声明的顺序先后执行
```

### 4.2 属性赋值位置、过程[#](https://www.cnblogs.com/deyo/p/17496096.html#42-%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E4%BD%8D%E7%BD%AE%E8%BF%87%E7%A8%8B)

```xml
1. 可以给类的非静态的属性（即实例变量）赋值的位置有：
① 默认初始化
② 显式初始化 / ③ 代码块中初始化
④ 构造器中初始化
***************************
⑤ 有了对象以后，通过"对象.属性"或"对象.方法"的方式给属性赋值


2. 执行的先后顺序：
① - ②/③ - ④ - ⑤

3. (超纲)关于字节码文件中的<init>\<clinit>的简单说明：

<clinit> : 系统自动生成的，内部包含了针对于静态属性的显式赋值、代码块中赋值操作。
           如果类中的静态属性没有显式赋值、没有静态代码块，则不会自动生成<clinit>方法。
           > 内部显式赋值、代码块中赋值操作的执行先后顺序取决于声明的先后顺序。

<init> : 系统自动生成的，内部包含了针对于非静态属性的显式赋值、代码块中赋值、构造器中赋值操作。
         > 一个字节码文件中至少包含一个<init>。换句话说，一个字节码文件中，包含几个<init>方法
           取决于类中声明了几个构造器。
         > 内部显式赋值、代码块中赋值操作的执行先后顺序取决于声明的先后顺序；构造器中赋值操作是最后执行的。
```

### 5. 关键字：final[#](https://www.cnblogs.com/deyo/p/17496096.html#5-%E5%85%B3%E9%94%AE%E5%AD%97final)

```dart
1. final的理解：最终的

2. final可以用来修饰的结构：类、方法、变量

3. 具体说明：

3.1 final修饰类：此类不能被继承。
        > 比如：String、StringBuffer、StringBuilder类都使用了final修饰。

3.2 final修饰方法：此方法不能被重写。
        > 比如：Object类中的getClass()

3.3 final修饰变量（重点关注）：表示此变量一旦赋值就不可更改，即此变量理解为是一个常量。
    > final修饰成员变量：此变量即为一个常量。
            可以有哪些位置给常量赋值呢？① 显式赋值 ② 代码块中赋值 ③ 构造器中赋值。


    > final修饰局部变量：此变量即为一个常量。
          此局部变量只能被赋值一次。针对于形参来讲，使用final修饰以后，在调用此方法时给此常量形参赋值。

4. final与static搭配：用来修饰一个属性，此属性称为：全局常量。
比如： Math类中的PI。
```

### 6. 关键字：abstract[#](https://www.cnblogs.com/deyo/p/17496096.html#6-%E5%85%B3%E9%94%AE%E5%AD%97abstract)

```rust
1. abstract的概念：抽象的

2. abstract可以用来修饰：类、方法

3. 具体的使用：
    abstract修饰类：抽象类
        > 不能实例化！
        > 抽象类中一定声明有构造器，只是不能创建对象而已。---> 此时的构造器，用来给子类对象实例化时调用的。
        > 抽象类中的方法可以是抽象方法，也可以是普通的非抽象方法。


    abstract修饰方法：抽象方法
        > 不包含方法体的方法，并且使用abstract修饰。
        > 抽象类中可以没有抽象方法，但是抽象方法所属的类一定是抽象类。
        > 子类继承抽象父类以后，如果重写了父类中的所有的抽象方法，此子类方可实例化。
                            如果子类没有重写父类中所有的抽象方法的话，则此子类必须也声明为抽象类。

4. abstract不能使用的场景
4.1 abstract 不能修饰哪些结构？属性、构造器、代码块等

4.2 abstract 不能与哪些关键字共用？
不能用abstract修饰私有方法、静态方法、final的方法、final的类。


5. 注意：
抽象类在使用时，如果出现在方法的形参位置。则在调用方法时，一定要使用多态了。
```

### 7. 与类并列的结构：接口(interface)[#](https://www.cnblogs.com/deyo/p/17496096.html#7-%E4%B8%8E%E7%B1%BB%E5%B9%B6%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E6%8E%A5%E5%8F%A3interface)

```java
1. 定义接口的关键字: interface

2. 接口的理解：
接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要...则必须能...”的思想。
继承是一个"是不是"的is-a关系，而接口实现则是 "能不能"的`has-a`关系。


3. 接口内部结构的说明：
   > 可以声明：
        jdk8之前：只能声明全局常量(public static final)、抽象方法(public abstract)
        ******************************************************
        jdk8中：增加了静态方法、默认方法(default)
        jdk9中：增加了私有方法。

   > 不可以声明：构造器、代码块等结构。


4. 接口与类的关系 ：实现关系(implements)

5. 满足此关系之后，说明：
> 实现类实现相应的接口以后，就获取了接口中声明的全局常量和抽象方法。
> 如果实现类重写了接口中声明的所有的抽象方法，则此实现类可以实例化
  如果实现类没有重写完接口中声明的所有的抽象方法，则此实现类仍为一个抽象类。
> 一个类可以实现多个接口。--->一定程度上缓解了Java中类的单继承性的局限性。


6. 格式：
class SubA extends SuperA implements A,B,C{}


7. 接口与接口的关系：继承关系，而且是多继承的。
interface A{
    void method1();
}
interface B{
    void method2();
}
interface C extends A,B{} //多继承

8. 接口的多态性（重要）


9. 面试题：区分抽象类和接口
角度1：
共性：都不能实例化
不同点：抽象类：有构造器
       接口：没有构造器

角度2：抽象类中可以声明抽象方法；接口中(jdk8之前)方法只能是抽象的。

角度3：类与类之间是继承关系，是单继承的；接口与接口之间是继承关系，是多继承的；类与接口之间是实现关系，是多实现的。

角度4：jdk8及之后的新特性：接口中可以声明静态方法、默认方法，包含方法体。
      jdk9：新增私有方法。
```

### 8. 类的内部成员之五：内部类[#](https://www.cnblogs.com/deyo/p/17496096.html#8-%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%E5%86%85%E9%83%A8%E7%B1%BB)

```markdown
> 内部类的分类（参照变量的分类）
> 如何创建成员内部类的对象
> 从两个角度来认识成员内部类（作为类、作为外部类的成员）
> 内部类如何调用外部类的成员（属性、方法）
    > 在出现同名的属性、方法时，使用"外部类.this.结构"的方式显式调用父类的结构。
> 谈谈局部内部类开发中的使用场景
```

### 9. 枚举类[#](https://www.cnblogs.com/deyo/p/17496096.html#9-%E6%9E%9A%E4%B8%BE%E7%B1%BB)

```scss
> 枚举类的特点：一个类中的对象个数是有限的、可数个的。
> （了解）jdk5.0之前，枚举类的定义方式。
> jdk5.0中新增了enum的方式定义枚举类。 ----需要掌握
> 自定义的枚举类的父类：Enum类。此类中声明的常用方法。
	> values() \ valueOf(String objName) \ toString() ; name() \ ordinal()
> 枚举类实现接口。
```

### 10. 注解[#](https://www.cnblogs.com/deyo/p/17496096.html#10-%E6%B3%A8%E8%A7%A3)

```markdown
> 注解的作用：与注释的区别。注解的作用
> Java基础中三个常见的注解
> 如何自定义注解
> 元注解：对现有的注解进行修饰作用的注解。
> 体会：框架的理解：框架 = 注解 + 反射 + 设计模式

> 掌握如何使用：单元测试方法。
```

### 11. 包装类[#](https://www.cnblogs.com/deyo/p/17496096.html#11-%E5%8C%85%E8%A3%85%E7%B1%BB)

```rust
> 理解：为什么需要包装类？
	> add(Object obj) / equals(Object obj)
> 基本数据类型以及对应的包装类
> 重点：基本数据类型、包装类、String三者之间的转换
	> 基本数据类型 < --- > 包装类：自动装箱、自动拆箱
	> 基本数据类型、包装类 ---> String: 调用String的valueOf(); + 
	> String ---> 基本数据类型、包装类：调用包装类的parseXxx(String str)
```

### 12.IDEA的使用[#](https://www.cnblogs.com/deyo/p/17496096.html#12idea%E7%9A%84%E4%BD%BF%E7%94%A8)

- IDEA常用的快捷键
- IDEA的debug功能